#!/usr/bin/python

import logging
import numpy as np
import pandas as pd

from exceptions import *
from pmgrobj import pmgrobj
from difflib import get_close_matches
from optparse import OptionParser
from sys import exit
from os import system
from ConfigParser import SafeConfigParser

class devconfig(object):
	"""
	Main devconfig class that interfaces with the pmgr

	Methods:
	.Gui()              Launches the pmgr gui for the given hutch and objType
	.View()             Shows device info from the pmgr
	.Search()           Searches the pmgr for the inputted obj/cfg/hutch/objType
	.New()              Add new objs/cfgs/hutch/objtypes to pmgr
	.Edit()             Edit existing objs/cfgs/hutch/objtypes
	.Diff()             Return diffs between inputted PVs, or PV and pmgr entry
	.Import()           Import cfg dict to pmgr
	.Save()             Save obj/cfg to pmgr
	.Apply()            Apply pmgr values to device
	.Update()           Search for updates, and/or update devconfig pmgr entries
	"""

	def __init__(self, **kwargs):
		# All meta data should be fetched from the pmgr
		# For now assume singular objType: ims_motor
		# Initialize instance-specific attributes
		self._hutches        = set()      #List of hutches to use in methods
		self._objTypes       = set()      #List of objTypes to use in methods
		self._localMode      = False      #Run devconfig in local mode
		# Grab attributes from the pmgr or cfg (set to None or empty for now)
		self._allHutches     = set()      #List of all valid hutches
		self._allObjTypes    = set()      #List of all valid objTypes
		self._hutchAliases   = {}         #Dict of alias:hutch(es) pairs
		self._objTypeNames   = {}         #Dict of objtype:device name pairs
		self._objTypeIDs     = {}         #Dict of objType:Identifying FLD pairs
		self._savePreHooks   = {}         #Dict of save objtype:prehook pairs
		self._savePostHooks  = {}         #Dict of save objtype:posthook pairs
		self._applyPreHooks  = {}         #Dict of apply objtype:prehook pairs
		self._applyPostHooks = {}         #Dict of apply objtype:posthook pairs
		self._verbosity      = {}         #Dict of hutch:verbosity level pairs
		self._logLevel       = {}         #Dict of hutch:logging level pairs
		self._loggingPath    = {}         #Dict of hutch:logging path pairs
		self._validLogLevels = set()      #Set of the valid logging levels
		self._logger         = None       #devconfig logger
		self._zenity         = {}         #Dict of hutch:T/F for zenity popups
		self._pmgr           = None       #Pmgr Obj used for devconfig operations
		self._successfulInit = False      #Attr to check if init was successful
		# Cached values to minimize number of lookups
		self._cachedObjs     = {}         #Dict of (SN,objType,hutch):ObjFLD Dict
		self._cachedCfgs     = {}         #Dict of (name,objType,hutch):cfgFLD Dict
		# Filling in all the attributes
		self._setInstanceAttrs(kwargs)    #Fills in instance attrs using inputs
		try:
			self._setPmgrAttrs()          #Looks up devconfig data in the pmgr
		except LocalModeEnabled:
			self._setLocalAttrs()
		self._initLogger()                #Setup the logger

	#############################################################################
	#                           Initialization Methods                          #
	#############################################################################	

	def _setInstanceAttrs(self, kwargs):
		"""Fills in the instance attributes using the inputted kw arguments."""
		if "hutches" in kwargs.keys():
			self._setHutches(kwargs["hutches"])
		if "objTypes" in kwargs.keys():
			self._objTypes = self._objTypes.union(set(kwargs["objTypes"]))
	    try:
			self._localMode = self._setLocalMode(kwargs["localMode"])
		except ValueError, KeyError:
			self._localMode = False
			
	def _setHutches(self, inpHutches):
		"""Sets _hutches checking _hutchAliases and _allHutches."""
		hutches = {hutch.lower() for hutch in set(inpHutches)}
		aliasesFound = {a for a in hutches if a in self._hutchAliases.keys()}
		for alias in aliasesFound:
			hutches.remove(alias)
			hutches = hutches.union(set(self._hutchAliases[alias]))
		validHutches = hutches.intersects(self._allhutches)
		if not validHutches:
			raise InvalidHutchError(inpHutches)
		self._hutches = validHutches
	
	def _setObjTypes(self, inpObjTypes):
		"""Sets _objTypes checking _allObjTypes."""
		objTypes = {objType.lower() for objType in set(inpObjTypes)}
		validObjTypes = objTypes.intersects(self._allobjTypes)
		if not validObjTypes:
			raise InvalidObjTypeError(inpObjTypes)
		self._objTypes = validObjTypes

	def _setLocalMode(self, mode):
		"""Sets local mode. Takes True or False"""
		if mode is True or mode is False:
			self._localMode = mode
		else: 
		    raise ValueError("Invalid input: {0}. Mode must be True or 
False".format(mode))

	def _setPmgrAttrs(self):
		"""Grabs all the devconfig data from the devconfig pmgr entries."""
		# # Uncomment this after devconfig has been added to the
		# self._allHutches.add('devconfig')
		# self._allObjTypes.add('devconfig')
		self._succesfulInit = False
		try:
			# Need to talk to Mike about getting new objtypes and hutch into
			# the pmgr.
			# High level architecture would be:
			# 	- Hutch: devconfig
			# 	- Objtypes:
			# 		- 
			self._pmgr = self._getPmgr('devconfig', 'devconfig')

			# ...
			self._succesfulInit = True
		except InvalidHutchError, InvalidObjTypeError:
			# This should never happen
			pass
		except pmgrInitError:
			# Initialize in local mode
			pass

	def _getPmgr(self, objType, hutch):
		"""
		Returns a pmgr object with the inputted objType and hutch. Because only
		one pmgrObj can be used at a time, entries for objType and hutch must be
		a single objType and hutch, not multiple.
		"""
		if self._localMode:
			raise LocalModeEnabled()
		if type(objType) is not str or type(hutch) is not str:
			raise typeError('str')
		if objType.lower() not in self._allObjTypes:
			raise InvalidObjTypeError(objType)
		if hutch.lower() not in self._allHutches:
			raise InvalidHutchError(hutch)
		try:
			pmgr = pmgrobj(objType.lower(), hutch.lower())
			pmgr.updateTables()
		except:
			raise pmgrInitError(objType, hutch)
		return pmgr

	def _setLocalAttrs(self):
		"""
	    Grabs as many devconfig pmgr-attributes from a local cfg file as it can.
		"""
		# Look to see if there is a way to 

	def _initLogger(self):
		# Make sure to handle concurrent devconfig use correctly
		pass

	#############################################################################
	#                          Outward Facing Methods                           #
	#############################################################################

	def Gui(self, **kwargs):
		"""
		Launches the parameter manager gui for specified hutch and objType. Will
		ask for hutch or objType if they are not provided.
		"""
		raise NotImplementedError()
		# Not working yet
		validHutches = set()
		if "hutches" in kwargs.keys():		
			validHutches = set(kwargs["hutches"]).intersection(self._allHutches)
			
		if "hutches" in kwargs.keys() and :
			self._hutches = set(kwargs["hutches"]).intersection(self._allHutches)
		elif "hutches" in kwargs.keys() and not set(
				kwargs["hutches"]).intersection(self._allHutches): 
			print "Invalid hutch entry"

    
	def View(self, ID):
		raise NotImplementedError()

	def Search(self):
		raise NotImplementedError()

	def New(self):
		raise NotImplementedError()
	
	def Edit(self):
		raise NotImplementedError()

	def Diff(self):
		raise NotImplementedError()

	def Import(self):
	    raise NotImplementedError()

	def Save(self):
		raise NotImplementedError()

	def Apply(self):
		raise NotImplementedError()

	def Revert(self):
		raise NotImplementedError()

	def Update(self):
		raise NotImplementedError()

	#############################################################################
	#                              Property Methods                             #
	#############################################################################
	
	def _returnDict(self, attr, **kwargs):
		"""Returns attrDict of the attr."""
		keys = set(kwargs.get("keys", set()))
	    validKeys = set(kwargs.get("validKeys", set()))
		if not keys:
			return attr
		elif not validKeys:
			return {key:attr[key] for key in keys}
		elif not keys.intersects(validKeys):
			raise pmgrKeyError(keys)
		else:
			return {key:attr[key] for key in keys.intersects(validKeys)}

	def _updateDict(self, attr, attrDict, **kwargs):
		"""Updates the attr using the attrDict"""
		if type(attrDict) is not dict or type(attr) is not dict:
			raise typeError('dict')
		validKeys = set(kwargs.get("validKeys", set()))
		validVals = set(kwargs.get("validVals", set()))
		for key in attrDict.keys():
			if validKeys:
				if key.lower() not in validKeys:
					print "Invalid key entry: {0}. Skipping.".format(key)
					continue
			if validVals:
				if attrDict[key] not in validVals:
					print "Invalid val entry: {0}. Skipping.".format(
						attrDict[key])
					continue
		    attr[key.lower()] = attrDict[key]

	#############################################################################
	#                            devconfig Properties                           #
	#############################################################################

	# Instance properties
	@property
	def hutches(self):
		"""Returns a set of devconfig instance hutches."""
		return self._hutches
	@hutches.setter
	def hutches(self, *args):
		"""Sets the instance hutches to the inputted tuple/list/set."""
		hutches = set()
		for arg in args:
		    hutches = hutches.union(set(arg))
		self._setHutches(hutches)
		
	@property
	def objTypes(self):
		"""Returns a set of devconfig instance objTypes."""
		return self._objTypes
	@objTypes.setter
	def objTypes(self, *args):
		"""Sets the instance objTypes to the inputed tuple/list/set."""
		objTypes = set()
		for arg in args:
		    objTypes = objTypes.union(set(arg))
		self._setObjTypes(objTypes)

	@property
	def localMode(self):
		"""Returns whether devconfig instance is in localMode."""
		return self._localMode
	@localMode.setter(self):
	def localMode(self, mode):
		"""Sets local mode to inputted mode (True/False)."""
		self._setLocalMode(mode)

	# Parameter manager fields. 
	@property
	def allHutches(self):
		"""Returns a set of all hutches currently in the pmgr."""
		return self._allHutches
	@allHutches.setter
	def allHutches(self, *args):
		"""Cannot set _allHutches. Included to remove setting functionality."""
		print "Cannot set allHutches"

	@property
	def allObjTypes(self, objTypes=set()):
		"""Returns a set of all objTypes currently in the pmgr."""
		return self._allObjTypes
	@allObjTypes.setter
	def allObjTypes(self, *args):
		"""Cannot set _allObjTypes. Included to remove setting functionality."""
		print "Cannot set allObjTypes"
		
	@property
	def hutchAliases(self, hutches=set()):
	    # Will need to modify the set and return dict methods for hutch aliases
	    # as the values are going to be sets.
		raise NotImplementedError()
	@hutchAliases.setter
	def hutchAliases(self, hutchAliasesDict):
	    # Need to make sure that when setting aliases that all hutches are valid
		raise NotImplementedError()

	@property
	def objTypeNames(self, objTypes=set()):
		"""Return the real-world names of the objTypes as objType:name dicts."""
		self._returnDict(self._objTypeNames, 
		                 keys      = objTypeNames,
		                 validKeys = self._allObjTypes)
	@objTypeNames.setter
	def objTypeNames(self, objTypeNamesDict):
	    """
	    Sets the objType names of the inputted objType(s) to that specified in
	    the dict.
	    """
	    self._updateDict(self._objTypeNames, objTypeNamesDict,
	                     validKeys = self._allObjTypes)

	@property
	def objTypeIDs(self, objTypes=set()):
	    """Returns the objType identifying field."""
	    self._returnDict(self._objTypeIDs, 
	                     keys      = objTypes,
	                     validKeys = self._allObjTypes)
	@objTypeIDs.setter
	def objTypeIDs(self, *args):
		"""This is included for the purpose of making it unavailable."""
		# Raise some form of invalid setting error
		print "Cannot set objType IDs - critical to devconfig functionality"

	@property
	def savePreHooks(self, objTypes=set()):
		"""
		Returns the path to the functions used as the savePreHook for each
		objType.
		"""
		self._returnDict(self._savePreHooks, 
		                 keys      = objTypes,
		                 validKeys = self._allObjTypes)
	@savePreHooks.setter
	def savePreHooks(self, savePreHooksDict):
		pass
		"""
		Sets the path to the functions used as the savePreHooks for an objType.
		"""
		self._updateDict(self._savePreHooks, savePreHooksDict,
		                 validKeys = self._allObjTypes)

	@property
	def savePostHooks(self, objTypes=set()):
		"""
		Returns the path to the functions used as the savePostHook for each
		objType.
		"""
		self._returnDict(self._savePostHooks, 
		                 keys      = objTypes,
		                 validKeys = self._allObjTypes)
	@savePostHooks.setter
	def savePostHooks(self, savePostHooksDict):
		"""
		Sets the path to the functions used as the savePostHooks for an objType.
		"""
		self._updateDict(self._savePostHooks, savePostHooksDict,
		                 validKeys = self._allObjTypes)

	@property
	def applyPreHooks(self, objTypes=set()):
		"""
		Returns the path to the functions used as the applyPreHook for each
		objType.
		"""
		self._returnDict(self._applyPreHooks, 
		                 keys      = objTypes,
		                 validKeys = self._allObjTypes)
	@applyPreHooks.setter
	def applyPreHooks(self, applyPreHooksDict):
		"""
		Sets the path to the functions used as the applyPreHooks for an objType.
		"""
		self._updateDict(self._applyPreHooks, applyPreHooksDict,
		                 validKeys = self._allObjTypes)

	@property
	def applyPostHooks(self, objTypes=set()):
		"""
		Returns the path to the functions used as the applyPostHook for each
		objType.
		"""
		self._returnDict(self._applyPostHooks, 
		                 keys      = objTypes,
		                 validKeys = self._allObjTypes)
	@applyPostHooks.setter
	def applyPostHooks(self, applyPostHooksDict):
		"""
		Sets the path to the functions used as the applyPostHooks for an objType.
		"""
		self._updateDict(self._applyPostHooks, applyPostHooksDict,
		                 validKeys = self._allObjTypes)

	@property
	def verbosity(self, hutches=set()):
		"""
		Returns a dictionary of the verbosity level set for the inputted 
		hutch(es). Returns all of them if none is specified.
		"""
		self._returnDict(self._verbosity, 
		                 keys      = hutches,
		                 validKeys = self._allHutches)

	@verbosity.setter
	def verbosity(self, verbosityDict):
		"""
		Sets the verbosity level of the hutch(es) to that specified in the 
		inputted {hutch:level} dictionary.
		"""
		self._updateDict(self._verbosity, verbosityDict, 
		                 validKeys = self._allHutches, 
		                 validVals = self._validLogLevels)

	@property
	def logLevel(self, hutches=set()):
		"""
		Returns a dictionary of the logLevel level set for the inputted 
		hutch(es). Returns all of them if none is specified.
		"""
		self._returnDict(self._logLevels, 
		                 keys      = hutches,
		                 validKeys = self._allHutches)

	@logLevel.setter
	def logLevel(self, logLevelDict):
		"""
		Sets the logLevel level of the hutch(es) to that specified in the 
		inputted {hutch:level} dictionary.
		"""
		self._updateDict(self._logLevels, logLevelDict, 
		                 validKeys = self._allHutches, 
		                 validVals = self._validLogLevels)
